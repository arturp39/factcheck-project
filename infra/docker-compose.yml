services:
  postgres-backend:
    # Backend relational DB. Persists data with volume `postgres_backend_data`.
    image: postgres:16
    container_name: factcheck-postgres-backend
    env_file:
      - .env
    environment:
      # DB init credentials
      POSTGRES_DB: ${BACKEND_POSTGRES_DB}
      POSTGRES_USER: ${BACKEND_POSTGRES_USER}
      POSTGRES_PASSWORD: ${BACKEND_POSTGRES_PASSWORD}
    ports:
      # HOST:CONTAINER mapping for local access (optional in production).
      - "${BACKEND_POSTGRES_PORT:-5433}:5432"
    volumes:
      # Persistent DB storage.
      - postgres_backend_data:/var/lib/postgresql/data
    networks:
      # Isolated internal network for inter-container traffic.
      - factcheck_net
    healthcheck:
      # pg_isready + query that ensures DB is up and accepts queries.
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${BACKEND_POSTGRES_USER} -d ${BACKEND_POSTGRES_DB} && psql -U ${BACKEND_POSTGRES_USER} -d ${BACKEND_POSTGRES_DB} -tAc \"SELECT 1\" >/dev/null 2>&1"
        ]
      interval: 5s
      timeout: 3s
      retries: 30
      # Give Postgres time to init DB + run /docker-entrypoint-initdb.d scripts.
      start_period: 25s

  postgres-collector:
    # Collector relational DB. Persists data with volume `postgres_collector_data`.
    image: postgres:16
    container_name: factcheck-postgres-collector
    env_file:
      - .env
    environment:
      # DB init credentials
      POSTGRES_DB: ${COLLECTOR_POSTGRES_DB}
      POSTGRES_USER: ${COLLECTOR_POSTGRES_USER}
      POSTGRES_PASSWORD: ${COLLECTOR_POSTGRES_PASSWORD}
    ports:
      # HOST:CONTAINER mapping for local access (optional in production).
      - "${COLLECTOR_POSTGRES_PORT:-5432}:5432"
    volumes:
      # Persistent DB storage.
      - postgres_collector_data:/var/lib/postgresql/data
    networks:
      # Isolated internal network for inter-container traffic.
      - factcheck_net
    healthcheck:
      # pg_isready + query that ensures DB is up and accepts queries.
      test:
        [
          "CMD-SHELL",
          "pg_isready -U ${COLLECTOR_POSTGRES_USER} -d ${COLLECTOR_POSTGRES_DB} && psql -U ${COLLECTOR_POSTGRES_USER} -d ${COLLECTOR_POSTGRES_DB} -tAc \"SELECT 1\" >/dev/null 2>&1"
        ]
      interval: 5s
      timeout: 3s
      retries: 30
      # Give Postgres time to init DB + run /docker-entrypoint-initdb.d scripts.
      start_period: 25s

  weaviate:
    # Vector DB. Persists vector index + schema via named volume `weaviate_data`.
    # Internal services should reach it via `http://weaviate:8080`.
    image: semitechnologies/weaviate:1.25.7
    container_name: factcheck-weaviate
    env_file:
      - .env
    environment:
      QUERY_DEFAULTS_LIMIT: ${WEAVIATE_QUERY_DEFAULTS_LIMIT}
      AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED: ${WEAVIATE_AUTH_ANON}
      PERSISTENCE_DATA_PATH: /var/lib/weaviate
      DEFAULT_VECTORIZER_MODULE: ${WEAVIATE_DEFAULT_VECTORIZER}
      CLUSTER_HOSTNAME: ${WEAVIATE_CLUSTER_HOSTNAME}
    ports:
      # Host port is customizable; container listens on 8080.
      - "${WEAVIATE_PORT:-8082}:8080"
    volumes:
      # Persistent Weaviate storage.
      - weaviate_data:/var/lib/weaviate
    networks:
      - factcheck_net
    healthcheck:
      # Weaviate readiness endpoint.
      test: ["CMD-SHELL", "wget -qO- http://localhost:8080/v1/.well-known/ready >/dev/null || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 30
      start_period: 10s

  nlp:
    # Embeddings and NLP preprocessing service. Built locally from ../factcheck-nlp-service.
    build:
      context: ../nlp-service
    image: factcheck-nlp:${IMAGE_TAG:-dev}
    container_name: factcheck-nlp
    env_file:
      - .env
    environment:
      NLP_PORT: 8000
      NLP_USE_FAKE_EMBEDDINGS: ${NLP_USE_FAKE_EMBEDDINGS:-true}
      NLP_LOG_LEVEL: ${NLP_LOG_LEVEL:-INFO}

      # Vertex/GCP config.
      GCP_PROJECT_ID: ${GCP_PROJECT_ID:-}
      GCP_LOCATION: ${GCP_LOCATION:-us-central1}
      NLP_VERTEX_MODEL: ${NLP_VERTEX_MODEL:-text-embedding-004}
      NLP_VERTEX_TASK_TYPE: ${NLP_VERTEX_TASK_TYPE:-RETRIEVAL_DOCUMENT}
      NLP_VERTEX_TIMEOUT_SECONDS: ${NLP_VERTEX_TIMEOUT_SECONDS:-30}
      NLP_VERTEX_BATCH_SIZE: ${NLP_VERTEX_BATCH_SIZE:-5}
      NLP_VERTEX_MAX_CALLS_PER_MINUTE: ${NLP_VERTEX_MAX_CALLS_PER_MINUTE:-5}
    ports:
      # Host access for testing /health, container on 8000.
      - "${NLP_PORT:-8000}:8000"
    depends_on:
      # NLP needs Weaviate ready if it writes vectors or schema on boot.
      weaviate:
        condition: service_healthy
    networks:
      - factcheck_net
    healthcheck:
      # Readiness probe used by depends_on in backend/collector.
      test:
        - CMD-SHELL
        - |
          python - <<'PY'
          import urllib.request, sys
          try:
              with urllib.request.urlopen('http://localhost:8000/health', timeout=3) as r:
                  sys.exit(0 if r.status == 200 else 1)
          except Exception:
              sys.exit(1)
          PY
      interval: 40s
      timeout: 3s
      retries: 30
      start_period: 10s
    restart: unless-stopped

  backend:
    # Main API backend (Spring Boot). Built from ../factcheck-backend.
    build:
      context: ../backend
    image: factcheck-backend:${IMAGE_TAG:-dev}
    container_name: factcheck-backend
    env_file:
      - .env
    environment:
      # Container listens on 8080.
      SERVER_PORT: 8080

      # DB connection.
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-backend:5432/${BACKEND_POSTGRES_DB}
      SPRING_DATASOURCE_USERNAME: ${BACKEND_POSTGRES_USER}
      SPRING_DATASOURCE_PASSWORD: ${BACKEND_POSTGRES_PASSWORD}

      # Service discovery inside docker network with service names.
      NLP_SERVICE_URL: http://nlp:8000
      WEAVIATE_BASE_URL: http://weaviate:8080
      WEAVIATE_API_KEY: ${WEAVIATE_API_KEY:-}

      # cloud config
      VERTEX_PROJECT_ID: ${VERTEX_PROJECT_ID:-}
      VERTEX_LOCATION: ${VERTEX_LOCATION:-us-central1}
      VERTEX_MODEL_NAME: ${VERTEX_MODEL_NAME:-gemini-2.5-flash}
      VERTEX_CREDENTIALS_PATH: ${VERTEX_CREDENTIALS_PATH:-}
    ports:
      # Exposes backend API to host for browser/Postman.
      - "${BACKEND_PORT:-8080}:8080"
    depends_on:
      # Ensure dependencies are ready before backend starts
      postgres-backend:
        condition: service_healthy
      weaviate:
        condition: service_healthy
      nlp:
        condition: service_healthy
    networks:
      - factcheck_net
    restart: unless-stopped

  collector:
    # collector (Spring Boot). Built locally from ../factcheck-news-collector.
    build:
      context: ../news-collector
    image: factcheck-collector:${IMAGE_TAG:-dev}
    container_name: factcheck-collector
    env_file:
      - .env
    environment:
      # Container listens on 8081, host mapping controls local access.
      SERVER_PORT: 8081
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE:-prod}

      # DB connection.
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres-collector:5432/${COLLECTOR_POSTGRES_DB}
      SPRING_DATASOURCE_USERNAME: ${COLLECTOR_POSTGRES_USER}
      SPRING_DATASOURCE_PASSWORD: ${COLLECTOR_POSTGRES_PASSWORD}

      # Dependencies inside docker network.
      NLP_SERVICE_URL: http://nlp:8000
      WEAVIATE_BASE_URL: http://weaviate:8080
      WEAVIATE_API_KEY: ${WEAVIATE_API_KEY:-}

    ports:
      # Exposes collector.
      - "${COLLECTOR_PORT:-8081}:8081"
    depends_on:
      postgres-collector:
        condition: service_healthy
      weaviate:
        condition: service_healthy
      nlp:
        condition: service_healthy
    networks:
      - factcheck_net
    restart: unless-stopped

networks:
  # Isolated bridge network for all services.
  factcheck_net:

volumes:
  # Persist DB and vector store data across container rebuilds.
  postgres_backend_data:
  postgres_collector_data:
  weaviate_data: